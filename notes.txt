Un graphe G = [V,E]
avec V : ensemble des sommets
et E : ensemble des arcs de V.
Chaque arc est valué par un cout (ou longueur) c(e).
Le pb du plus court chemin entre deux sommets i et j
	consiste à trouver un chemin de i à j de coût
	total minimal.

sommetadjacent : std::pair<int,int>
un sommet adjacent j, à un noeud i, est une pair (j, longueur de l'arête (i,j))

vect : vector<sommetadjacent>
liste des sommets adjacents à i

listeadjacence : vector<vec>
C'est un vector indicé par les numéros i=0,1,2,...,n-1 des sommets.
Pour chaque i, le vecteur contient la liste des sommets adjacents à i.

Dans l'algo, cji est la distance (directe) entre les sommets j et i. 0 s'il n'y a pas de chemin.
	-> a lire dans la liste d'adjacence


1) Init de d
2) init de T
3) init de I
4) On change les distances vers voisins du noeud pivot (élement 0 ici).
	Le nouveau pivot est obtenu en supprimant du tas son élement min, soit T[0].
	Le contenu de I change en conséquence



pour chaque element j (tous les noeuds sauf pivot), qui est strictement sup à -1, ..



##
Etant donné que std::pop_heap rearranges le tableau de manière non voulue (la premiere
	valeur n'est pas toujours la plus petite), alors je déplace moi meme la valeur la 
	plus petite dans T[0].
J'ai pourtant bien utilisé une fonction de comparaison pour former une Min Heap.
##

Il faut que j'update I en fonction de T à chaque itération.
